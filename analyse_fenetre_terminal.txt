--- analyse_fenetre_terminal.txt ---
Documentation de la Gestion de Fenêtre du Terminal Holaf et du Panel Manager
Objectif de ce document

Ce document analyse le fonctionnement de la création et de la gestion des fenêtres flottantes. Initialement basé sur l'implémentation du Terminal Holaf, il a été étendu pour couvrir la création d'un HolafPanelManager générique. L'objectif est de comprendre les mécanismes qui rendent ces fenêtres fonctionnelles et robustes, afin de pouvoir les utiliser pour tous les outils (Terminal, Model Manager, etc.).

    Flux de Création et d'Affichage (Exemple avec le Terminal)

Le processus démarre lorsque l'utilisateur clique sur l'élément de menu "Terminal".

    Création du Menu (js/holaf_main.js et js/holaf_terminal.js) :

        holaf_main.js crée le bouton principal "Utilities" et une liste vide (<ul>) pour le menu déroulant. Il charge également le CSS partagé holaf_utilities.css.

        holaf_terminal.js, via sa fonction addMenuItem(), ajoute un élément de liste (<li>Terminal</li>) à ce menu.

        Un écouteur d'événement onclick est attaché à cet élément de liste.

    Déclenchement de l'affichage (js/holaf_terminal.js) :

        Le clic sur "Terminal" appelle la méthode holafTerminal.show().

        La méthode show() effectue plusieurs actions :

            Elle s'assure que les scripts nécessaires (xterm.js, xterm-addon-fit.js) sont chargés via ensureScriptsLoaded().

            Elle appelle this.createPanel() uniquement si le panneau n'a pas encore été créé (if (!this.panelElements)). Le panneau est donc un singleton.

            Elle applique les paramètres de position et de taille sauvegardés.

            Elle change le style du panneau pour le rendre visible : this.panelElements.panelEl.style.display = "flex";.

            Elle vérifie l'état du serveur (mot de passe, etc.) pour afficher la vue appropriée (login, setup, terminal).

    Anatomie du Panneau (DOM) - via HolafPanelManager

La méthode HolafPanelManager.createPanel() (js/holaf_panel_manager.js) construit la structure HTML complète du panneau :

    Un div principal avec l'ID fourni (ex: #holaf-terminal-panel). C'est le conteneur de tout le panneau. Il porte la classe .holaf-utility-panel.

    À l'intérieur de ce div, on trouve :

        Un div pour l'en-tête (.holaf-utility-header), qui contient le titre (fourni) et un bouton de fermeture standard. C'est sur cet élément que le glisser-déposer (drag) est activé. Du contenu additionnel peut être injecté dans le header (ex: boutons de thème/font pour le terminal).

        Un div pour le contenu (sans classe spécifique au manager, style flex-grow: 1). C'est ce contentEl qui est retourné à l'outil appelant (ex: holafTerminal) pour qu'il y insère son propre contenu (vues de connexion, xterm.js, etc.).

        Un div pour la poignée de redimensionnement (.holaf-utility-resize-handle), positionné en bas à droite.

Une fois construit, panelEl (le div principal du panneau) est ajouté directement à document.body.

    Gestion du Style (CSS)

Deux niveaux de style :

    CSS Partagé (js/css/holaf_utilities.css) :

        Chargé par js/holaf_main.js.

        Contient les styles pour la classe .holaf-utility-panel (positionnement initial, bordure, ombre, z-index, etc.), .holaf-utility-header, .holaf-utility-close-button, et .holaf-utility-resize-handle.

        Problème initial résolu : Le chemin de chargement de ce fichier a été corrigé en déplaçant le dossier css dans js et en ajustant le link.href dans holaf_main.js car WEB_DIRECTORY est "js".

    CSS Spécifique à l'outil (Exemple : js/holaf_terminal.js) :

        Le holafTerminal.js injecte dynamiquement une balise <style> dans le <head> du document.

        Cette balise contient des styles spécifiques au terminal (police monospace, agencement des boutons dans le header du terminal, styles pour les vues de login/setup).

        Cette approche rend le composant terminal partiellement autonome pour ses styles internes, le protégeant des régressions si le CSS partagé était modifié de manière incompatible.

    Gestion de la Position et de la Taille (Glisser-Déposer et Redimensionnement) - HolafPanelManager

Les méthodes makeDraggable() et makeResizable() dans HolafPanelManager implémentent cette logique.

    Principe : Elles attachent un écouteur mousedown sur l'en-tête (pour le drag) ou la poignée (pour le resize).

    Déroulement :

        Au mousedown, elles enregistrent la position/taille de départ et ajoutent des écouteurs mousemove et mouseup au document entier.

        La fonction _bakePosition(panel) est appelée au mousedown.

            Au premier affichage, si le panneau est centré avec transform: translate(-50%, -50%).

            _bakePosition "cuit" cette position transformée en valeurs top et left absolues en pixels et supprime la transformation.

            Cela permet au reste de la logique de fonctionner de manière simple avec des coordonnées en pixels.

        Pendant le mousemove, elles mettent à jour les propriétés style.left, style.top, style.width et style.height du panneau en temps réel.

        Au mouseup, elles retirent les écouteurs mousemove et mouseup du document et appellent le callback onStateChange fourni par l'outil.

    État actuel du débogage (avant dernière modification non testée) :

        Les logs montrent que les événements mousedown, mousemove (avec logs décommentés), et mouseup sont capturés.

        Les styles left, top, width, height du panneau semblent être mis à jour en JavaScript.

        Le callback onStateChange est appelé à la fin, et les nouvelles coordonnées/dimensions sont sauvegardées via l'API.

        Cependant, l'utilisateur ne voit pas le panneau se déplacer ou se redimensionner visuellement pendant l'interaction, bien que les positions/dimensions finales (après mouseup) soient parfois correctes. Cela suggère un problème de rendu ou de capture d'événement plus subtil.

    Persistance de l'État (Position et Taille) - via l'outil (ex: Terminal)

    Après un drag ou un resize, le callback onStateChange du HolafPanelManager est appelé.

    Dans holafTerminal.js, ce callback appelle this.saveSettings().

    saveSettings() envoie une requête POST à l'API /holaf/terminal/save-settings avec les nouvelles coordonnées (panel_x, panel_y) et dimensions (panel_width, panel_height).

    Le backend Python sauvegarde ces valeurs dans le fichier config.ini.

    Lors du prochain chargement ou de la réouverture du panneau, la méthode applySettings() (appelée dans show()) lit ces valeurs (récupérées via l'API /holaf/terminal/status) et applique la position et la taille sauvegardées au panneau.

Conclusion et Diagnostic (en cours)

    La création du panneau via HolafPanelManager et l'application des styles de base via holaf_utilities.css fonctionnent (le panneau s'affiche avec les styles de test).

    La logique interne du terminal (chargement des vues de login/setup, connexion websocket) semble progresser correctement.

    Le problème principal restant est l'absence de retour visuel pendant le drag et le resize, malgré des logs indiquant que les événements et les mises à jour de style sont en cours.

        Les scripts xterm.js et xterm-addon-fit.js sont bien chargés.

        Les appels à fitTerminal() avant l'initialisation complète de xterm échouent logiquement (conditions non remplies), ce qui est normal.

        L'enquête se poursuit sur pourquoi les mises à jour de style left, top, width, height dans les boucles mousemove de HolafPanelManager ne se traduisent pas par un mouvement/redimensionnement visuel en temps réel.

La solution pour les futurs outils (Model Manager) sera d'adopter HolafPanelManager pour une gestion unifiée et robuste des fenêtres.